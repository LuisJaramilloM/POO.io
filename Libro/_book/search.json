[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Libro",
    "section": "",
    "text": "Programación Orientada a Objetos\nLa programación orientada a objetos (POO) es un paradigma de programación que se basa en el concepto de “objetos”, los cuales son instancias de clases. En POO, un “objeto” puede entenderse como una entidad que encapsula datos y funciones que operan sobre esos datos. Este enfoque permite modelar el mundo real de manera más efectiva, ya que se pueden representar entidades y sus interacciones de manera más natural.\nEn POO, una “clase” es un plano o plantilla para crear objetos. Define la estructura y el comportamiento de los objetos que se crearán a partir de ella. Los objetos son instancias concretas de una clase, y cada objeto puede tener sus propios datos (llamados atributos) y funciones (llamadas métodos).\nLos cuatro principios fundamentales de la POO son la encapsulación, la herencia, el polimorfismo y la abstracción. La “encapsulación” implica la ocultación de los detalles internos de un objeto y la exposición solo de lo necesario. La “herencia” permite la creación de nuevas clases basadas en clases existentes, heredando sus atributos y métodos. El “polimorfismo” permite que un objeto pueda tomar varias formas, es decir, un mismo método puede comportarse de manera diferente según el contexto. La “abstracción” consiste en simplificar la representación de un objeto centrándose en los aspectos esenciales y omitiendo los detalles innecesarios. Para el siguiente documento revisaremos las siguientes temáticas:\nPrimer Parcial\n\nControl de versionamiento\nEntorno de Desarrollo\nParadigmas de programación\nConceptos Generales de la POO\nModelamiento de clases y objetos\nCódigo limpio\nEstructura General de un Programa - ———————————————-\nLectura y escritura de datos por consola\nManejo de Excepciones\nEncapsulamiento\nConstructores\nMétodos Getter y Setters\nPersistencia de datos\nArreglos y Colecciones\n\n2 Parcial - Relaciones entre clases (Generalización/Especialización) - Revisiones de Código - Polimorfismo - Interfaces de Programación - Modelo Vista Controlador - Bases de Datos no SQL - Componentes y Objetos Gráficos\n3er Parcial - Principios SOLID - Modularidad - Introducción a Patrones de diseño - Patrones de creación - Patrones de Estructura - Patrones de Comportamiento"
  },
  {
    "objectID": "Unidades/unidad1/intro.html",
    "href": "Unidades/unidad1/intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "Unidades/unidad2/cap2.html",
    "href": "Unidades/unidad2/cap2.html",
    "title": "2  ENTORNO DE DESARROLLO.",
    "section": "",
    "text": "Un entorno de desarrollo, comúnmente conocido como IDE por sus siglas en inglés (Integrated Development Environment), es una herramienta de software integral que se utiliza para facilitar la programación y el desarrollo de software. Un IDE proporciona un conjunto de características y herramientas que ayudan a los programadores a escribir, depurar, compilar y administrar código de manera más eficiente, en otras palabras es un paquete de software que combina todas las herramientas de desarrollo en una única interfaz gráfica de usuario (GUI), Algunos ejemplos de IDE más utilizados son NetBeans, Microsoft Visual Studio, Adobe Flex Builder y Eclipse.\nAlgunos componentes comunes de un entorno de desarrollo incluyen:\nEditor de código: Ofrece funciones de edición de texto avanzadas, como resaltado de sintaxis, autoindentación y autocompletado, lo que facilita la escritura de código.\nLa Identación se refiere al formato visual utilizado para estructurar y organizar el código fuente en un lenguaje de programación.\n\n\n\n\n\nDepurador: Permite a los programadores identificar y corregir errores en su código al proporcionar herramientas para establecer puntos de interrupción, inspeccionar variables y seguir la ejecución del programa paso a paso.\nCompilador/Intérprete: Proporciona la capacidad de compilar y ejecutar el código directamente desde el IDE. Algunos IDE también son específicos para un lenguaje y pueden incluir un intérprete para ejecutar el código directamente.\nGestión de proyectos: Permite organizar y administrar proyectos de desarrollo, lo que incluye la creación, apertura y gestión de archivos y directorios.\nHerramientas de versionado: Puede integrar sistemas de control de versiones, como Git, para realizar un seguimiento de los cambios en el código y colaborar con otros desarrolladores.\nAsistencia en el desarrollo: Ofrece sugerencias y advertencias en tiempo real mientras se escribe código, lo que ayuda a detectar posibles errores y mejorar la calidad del código.\nHerramientas de construcción: Facilita la construcción y automatización de tareas, como la compilación, la generación de documentación y la ejecución de pruebas.\nHerramientas de depuración visual: Algunos IDE proporcionan una interfaz gráfica para depurar aplicaciones de manera más visual, lo que puede incluir representaciones gráficas de estructuras de datos y flujos de programa.\nIntegración con SDK y bibliotecas: Puede integrar SDK (kits de desarrollo de software) y bibliotecas relevantes para el lenguaje o plataforma de desarrollo específico.\nFinalización de código: conocida como prompt de código, esta función se utiliza para analizar todo el código y para identificar e insertar los componentes de código que faltan. Su uso permite ahorrar tiempo y minimizar los fallos o errores\nPor ejemplo, un SDK de Android proporciona las herramientas y recursos necesarios para desarrollar aplicaciones para dispositivos Android, incluyendo bibliotecas para interactuar con el hardware y el sistema operativo, herramientas de depuración, un emulador de Android para probar aplicaciones y documentación detallada.\nLos IDE varían según el lenguaje de programación y la plataforma de desarrollo. Ejemplos populares de IDE incluyen Visual Studio (para desarrollo en C# y .NET), Eclipse (para Java), IntelliJ IDEA (para Java y otros lenguajes), PyCharm (para Python) y muchos otros. La elección de un IDE suele depender de las preferencias del desarrollador y del entorno de desarrollo específico en el que trabaje.\nCARACTERISTICAS E INTSALACIÓN.\nPara este curso se utilizará los lenguajes de programación de Python y Java, por lo que instalaremos dos entornos virtuales, para sacar el mayor provecho en el caso del lenguaje de programación Java.\nEl primer entorno virtual será Visual Studio Code  y el IDE para el lenguaje de programación será Netbeans IDE 16 .\nPara la instalación del IDE Visual Studio Code hay que seguir los siguientes pasos.\nPaso 1: Descarga de VS Code\nDirígete al sitio web oficial de Visual Studio Code en https://code.visualstudio.com/ y busca un botón de descarga, generalmente ubicado en la página principal. Aquí deberías encontrar una imagen que representa el botón de descarga.\n\nPaso 2: Selecciona tu Sistema Operativo, en mi caso Windows 10.\nPaso 3: Descarga del Instalador\nDespués de seleccionar tu sistema operativo, deberías ser redirigido a una página que te permitirá descargar el instalador específico para tu plataforma. Aquí encontrarás un enlace de descarga o un botón para iniciar la descarga, donde señalarás la carpeta y realizará la descarga.\nPaso 4: Ejecuta el Instalador\nUna vez que se complete la descarga, ejecuta el instalador haciendo doble clic en él (en Windows) o siguiendo las instrucciones específicas para tu sistema operativo.\nDurante la instalación, se te pueden presentar opciones de configuración. Estas opciones pueden variar según la versión y la plataforma. Generalmente, se te preguntará si deseas crear accesos directos en el escritorio o en el menú de inicio (en el caso de Windows), así como otras preferencias.\nPaso 5: Finaliza la Instalación\nFinalmente, cuando se complete la instalación, verás una pantalla que confirma que Visual Studio Code se ha instalado correctamente.\n\nPaso 6: Configuración de los lenguajes.\nLa configuración de los lenguajes es muy importante ya que este nos permite al momento de ejecutar los archivos con sus diferentes extensiones que corran de manera correcta, para este curso instalaremos Python y luego netbeans por lo que los pasos a seguir son los siguientes:\nPaso 1: Descargar Python: Ve al sitio web oficial de Python en https://www.python.org/downloads/.\nEn la página de descargas, verás las últimas versiones de Python disponibles. Elige la versión más reciente de Python 3 (por ejemplo, Python 3.9.6).\nDesplázate hacia abajo hasta encontrar la sección de descargas de archivos ejecutables. Dependiendo de tu sistema operativo (Windows, macOS o Linux), selecciona el enlace de descarga adecuado. Para Windows, es posible que veas dos opciones: una para 32 bits y otra para 64 bits. Si tienes un sistema operativo de 64 bits, selecciona la versión de 64 bits.\nPaso 2: Ejecutar el Instalador de Python: Una vez que se complete la descarga, haz doble clic en el archivo ejecutable que descargaste para iniciar el instalador de Python.\nAsegúrate de marcar la casilla que dice “Add Python X.Y to PATH” (donde “X.Y” representa la versión de Python que estás instalando). Esto añadirá Python al PATH de tu sistema, lo que facilitará su uso desde la línea de comandos.\nHaz clic en “Install Now” para comenzar la instalación.\nPaso 3: Verificar la Instalación de Python: Abre una terminal o línea de comandos, Escribe el siguiente comando y presiona Enter:\nbash\nCopy code\npython –version\nEsto mostrará la versión de Python que has instalado, como “Python 3.9.6” o similar.\nInstalación del Netbeans."
  },
  {
    "objectID": "Unidades/unidad3/cap3.html",
    "href": "Unidades/unidad3/cap3.html",
    "title": "3  Introducción a los Paradigmas de Programación",
    "section": "",
    "text": "Los paradigmas de programación son enfoques o estilos para resolver problemas mediante código. Cada paradigma tiene sus principios, ventajas y desventajas, y está diseñado para abordar problemas de diferentes maneras. En este documento, exploraremos cuatro paradigmas principales: imperativo, declarativo, orientado a objetos y funcional.\n\n3.1 Paradigma Imperativo\n\nEl paradigma imperativo es uno de los enfoques más tradicionales. En él, el programador indica paso a paso cómo se debe realizar cada tarea.\n\nCaracterísticas:\n\nEnfoque en cambiar el estado mediante secuencias de instrucciones.\nUso intensivo de bucles y estructuras de control de flujo (if, else, for, while).\n\nEjemplo en Java\n\nEn Java, este paradigma se utiliza ampliamente debido a su sintaxis estructurada.\npublic class SumaImperativa {\n    public static void main(String[] args) {\n        int sum = 0;\n        for (int i = 1; i &lt;= 5; i++) {\n            sum += i;\n        }\n        System.out.println(\"La suma es: \" + sum);\n    }\n}\n\n3.2 Paradigma Declarativo\n\nEn el paradigma declarativo, el programador especifica qué se quiere lograr, no cómo hacerlo. Esto permite centrarse en el resultado y no en los pasos intermedios.\n\nCaracterísticas:\n\nDescribe el resultado deseado en lugar de los pasos detallados.\nMás conciso y fácil de leer para tareas específicas como consultas de bases de datos.\nEjemplo con Java y SQL\n\n\nEn Java, el uso de SQL en aplicaciones es un ejemplo de un enfoque declarativo.\nSELECT nombre, edad FROM estudiantes WHERE edad &gt; 18;\n\n3.3 Paradigma Orientado a Objetos\n\nLa programación orientada a objetos (POO) es ampliamente utilizada en Java. Este paradigma organiza el código en “objetos”, que representan entidades del mundo real.\n\nCaracterísticas:\n\nUsa conceptos de clases y objetos.\nPrincipios de abstracción, encapsulación, herencia y polimorfismo.\n\nEjemplo en Java\n\nAquí un ejemplo básico de POO en Java:\n\nclass Persona {\n    String nombre;\n    int edad;\n\n    public Persona(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n    }\n\n    public void presentarse() {\n        System.out.println(\"Hola, soy \" + nombre + \" y tengo \" + edad + \" años.\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Persona persona = new Persona(\"Ana\", 25);\n        persona.presentarse();\n    }\n}\n\n\n\n3.4 Paradigma Funcional.\n\nEl paradigma funcional trata las funciones como ciudadanos de primera clase. En este estilo, se evita el cambio de estado y las variables mutables.\n\nCaracterísticas:\n\nUso de funciones puras (sin efectos secundarios).\nUso de funciones de orden superior y técnicas como el mapeo y el filtrado.\n\nEjemplo en Java.\n\nmagina que tienes una lista de números y quieres obtener solo los números pares y calcular el doble de cada uno de ellos. En el paradigma funcional, no describimos cada paso de cómo lograr esto con bucles o variables que cambien, sino que aplicamos funciones que transforman la lista de manera declarativa. 1. Primero, aplicamos una función de filtro para seleccionar solo los números pares. 2. Luego, aplicamos una función de mapeo para multiplicar cada número par por dos. 3. Finalmente, obtenemos el resultado como una nueva lista.\nTest"
  },
  {
    "objectID": "Unidades/unidad4/cap4.html",
    "href": "Unidades/unidad4/cap4.html",
    "title": "4  Conceptos Generales de la POO",
    "section": "",
    "text": "5 Polimorfismo\nEl polimorfismo permite que objetos de diferentes clases respondan al mismo método de formas distintas, aumentando la flexibilidad del código."
  },
  {
    "objectID": "Unidades/unidad4/cap4.html#principios-fundamentales-de-la-poo",
    "href": "Unidades/unidad4/cap4.html#principios-fundamentales-de-la-poo",
    "title": "4  Conceptos Generales de la POO",
    "section": "4.1 Principios Fundamentales de la POO",
    "text": "4.1 Principios Fundamentales de la POO\nLa POO se basa en cuatro principios clave: Clases y Objetos, Encapsulación, Herencia y Polimorfismo. A continuación, veremos cada uno en detalle."
  },
  {
    "objectID": "Unidades/unidad4/cap4.html#clases-y-objetos",
    "href": "Unidades/unidad4/cap4.html#clases-y-objetos",
    "title": "4  Conceptos Generales de la POO",
    "section": "4.2 1 Clases y Objetos",
    "text": "4.2 1 Clases y Objetos\n\n4.2.1 Clases\nUna clase es una plantilla o modelo que define las propiedades y comportamientos de un tipo de objeto. Es como un plano que describe cómo debe ser un objeto.\n\n\n\n\n\npublic class Persona { // NOMBRE DE LA CLASE\n    String nombre;     // ATRIBUTO\n    int edad;\n\n    public void presentarse() { // METODO\n        System.out.println(\"Hola, soy \" + nombre + \" y tengo \" + edad + \" años.\");\n    }\n}\n\n\n4.2.2 Objetos\nUn objeto es una instancia concreta de una clase. Cuando se crea un objeto, se asigna un espacio en memoria y se puede interactuar con sus atributos y métodos.\npublic class Main {\n    public static void main(String[] args) {\n        Persona persona = new Persona();\n        persona.nombre = \"Ana\";\n        persona.edad = 25;\n        persona.presentarse();\n    }\n}\nEn este ejemplo, persona es un objeto de la clase Persona con atributos nombre y edad."
  },
  {
    "objectID": "Unidades/unidad4/cap4.html#encapsulación",
    "href": "Unidades/unidad4/cap4.html#encapsulación",
    "title": "4  Conceptos Generales de la POO",
    "section": "4.3 2. Encapsulación",
    "text": "4.3 2. Encapsulación\nLa encapsulación consiste en restringir el acceso directo a ciertos datos de un objeto, protegiendo sus atributos para que solo se modifiquen a través de métodos específicos.\n\n\n\n\n\n\n4.3.1 Ejemplo de Encapsulación\nclass Persona {\n    public String nombre;\n    private int edad;\n\n    public Persona(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public String getEdad() {\n        return edad;\n    }\n\n    public void setEdad(int edad) {\n        this.edad = edad;\n    }\n}\nEn este caso, el atributos nombre es público y edad es privados, y solo se pueden acceder mediante los métodos getEdad() y setEdad()."
  },
  {
    "objectID": "Unidades/unidad4/cap4.html#herencia",
    "href": "Unidades/unidad4/cap4.html#herencia",
    "title": "4  Conceptos Generales de la POO",
    "section": "4.4 3 Herencia",
    "text": "4.4 3 Herencia\nLa herencia permite que una clase (subclase) herede atributos y métodos de otra clase (superclase), permitiendo reutilizar código y extender funcionalidades.\n\n\n\n\n\nEjemplo de Herencia\nclass Animal {\n  public String nombre;\n  public Animal (String nombre){\n    this.nombre = nombre;\n  } \n  public void sonido() {\n        System.out.println(\"El animal hace un sonido\");\n  }\n}\n\nclass Perro extends Animal {\n  @Override\n  public void sonido() {\n      System.out.println(\"El perro ladra\");\n  }\n}\nAquí, Perro es una subclase de Animal y hereda el atributo nombre y su método sonido(), que luego sobrescribimos (@verride) para proporcionar un comportamiento específico."
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#tipos-de-relaciones-diagramas-de-casos-de-usos.",
    "href": "Unidades/unidad5/cap5.html#tipos-de-relaciones-diagramas-de-casos-de-usos.",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.1 TIPOS DE RELACIONES | DIAGRAMAS DE CASOS DE USOS.",
    "text": "5.1 TIPOS DE RELACIONES | DIAGRAMAS DE CASOS DE USOS.\nLos diagramas de casos de uso muestran los casos de uso, los actores y las relaciones entre ellos. \nEs, con total seguridad, el diagrama más conocido y es utilizado para representar los actores externos que interactúan con el sistema de información y a través de que funcionalidades (casos de uso o requisitos funcionales) se relacionan. Dicho de otra manera, muestra de manera visual las distintas funciones que puede realizar un usuario (más bien un tipo de usuario) de un Sistema de Información.\nLo primero es saber cual es su finalidad. El diagrama de casos de uso, dependiendo de la profundidad que le demos, puede ser utilizado para muchos fines, entre ellos podemos encontrar los siguientes:\n\nRepresentar los requisitos funcionales.\nRepresentar los actores que se comunican con el sistema. Normalmente los actores del sistema son los usuarios y otros sistemas externos que se relacionan con el sistema. En el caso de los usuarios hay que entender el actor como un “perfil”, pudiendo existir varios usuarios que actúan como el mismo actor.\nRepresentar las relaciones entre requisitos funcionales y actores.\nGuiar el desarrollo del sistema. Crear un punto de partida sobre el que empezar a desarrollar el sistema.\nComunicarse de forma precisa entre cliente y desarrollador. Simplifica la forma en que todos los participes del desarrollo, incluyendo el cliente, perciben como el sistema funcionará y ofrecerá una visión general común del mismo."
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#elementos-de-un-diagrama-de-casos-de-uso",
    "href": "Unidades/unidad5/cap5.html#elementos-de-un-diagrama-de-casos-de-uso",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.2 Elementos de un diagrama de casos de uso",
    "text": "5.2 Elementos de un diagrama de casos de uso\nUn diagrama de casos de uso está compuesto, principalmente, de 3 elementos: Actores, Casos de uso y Relaciones.\nLa interacción entre actores no se ve en el diagrama de casos de uso. Si esta interacción es esencial para una descripción coherente del comportamiento deseado, quizás los límites del sistema o del caso de uso deban de ser re-examinados. Alternativamente, la interacción entre actores puede ser parte de suposiciones usadas en el caso de uso. Sin embargo, los actores son una especie de rol, un usuario humano u otra entidad externa puede jugar varios papeles o roles. Así el Chef y el Cajero podrían ser realmente la misma persona.\n\n\n5.2.1 Actores\nComo ya hemos comentado en la presentación, un actor es algo o alguien externo al sistema que interactúa de forma directa con el sistema. Cuando decimos que interactúa nos referimos a que aporta información, recibe información, inicia una acción…\nSe representan con una imagen de un “muñeco de palo” con el nombre del actor debajo\n\nExisten dos tipos de actores: Los usuarios y los sistemas.\nNo hay que entender los usuarios como personas singulares, sino como “perfiles o roles” que identifican a un tipo de usuario, pero no al usuario en sí. Por ejemplo, en una aplicación de gestión de nóminas, un actor de este tipo podría ser “gestor de nóminas” que se encarga de emitir y firmar nóminas. Este rol podría ser tomado, por ejemplo, por cualquier individuo del personal de recursos humanos y, además, por el jefe de la empresa. Es un ejemplo muy sencillo, pero como puedes ver, un actor no representa a una única persona o a un único usuario.\n\nPor otro lado, los actores pueden ser otros sistemas que también interactúan con nuestro propio sistema. Un ejemplo podría ser, en nuestra aplicación de nóminas, un sistema que almacene las nóminas firmadas a modo de archivo. En este caso cuando se firma la nómina se recibe la misma por el sistema de archivo, por tanto el caso de uso se relaciona con el actor.\n\nEn ocasiones este tipo de actores no se representa con un “hombre de palo” porque puede dar la sensación de que es un usuario y queda poco intuitivo."
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#relaciones",
    "href": "Unidades/unidad5/cap5.html#relaciones",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.3 Relaciones",
    "text": "5.3 Relaciones\nLas relaciones conectan los casos de uso con los actores o los casos de uso entre sí.\nCuando conectan un actor con un caso de uso representa que ese actor interactúa de alguna manera con ese caso de uso y se representa con una linea continua con la identificación &lt;&lt;communicates&gt;&gt;.\n\nCuando conectan casos de uso entre sí se pueden diferenciar dos tipos de relaciones: &lt;&lt;include&gt;&gt; y &lt;&lt;extends&gt;&gt;. En español a veces se usa la nomenclatura &lt;&lt;usa&gt;&gt; y &lt;&lt;extiende&gt;&gt;:\n\n&lt;&lt;include&gt;&gt;: Se utiliza para representar que un caso de uso utiliza siempre a otro caso de uso. Es decir, un caso de uso se ejecutará obligatoriamente (lo incluye, lo usa). Se representa con una flecha discontinua que va desde el caso de uso de origen al caso de uso que se incluye.\n\n\nUn uso típico de este tipo de relaciones se produce cuando dos casos de uso comparten una funcionalidad. Esa funcionalidad es extraida de los dos y se crea un caso de uso nuevo que se relaciona con los anteriores con un include.\n\nEn este ejemplo, los casos de uso emitir factura y enviar producto ejecutarán ambos el caso de uso autenticación.\n\n&lt;&lt;extend&gt;&gt;: Este tipo de relaciones se utilizan cuando un caso de uso tiene un comportamiento opcional, reflejado en otro caso de uso. Es decir, un caso de uso puede ejecutar, normalmente dependiendo de alguna condición o flujo del programa, otro caso de uso. Se representa con una flecha discontinua que va desde el caso de uso opcional al original.\n\n\nUn ejemplo de esta relación podría ser la siguiente:\n\nEn este supuesto el caso de uso Hacer pedido puede dar lugar (o no) a otros dos casos de uso: Enviar notificación SMS y Enviar notificación email. Se supone que, cuando un usuario hace un pedido, el sistema le permite elegir si quiere que se envíe una notificación de ese pedido por SMS o por email"
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#tipos-de-relaciones.",
    "href": "Unidades/unidad5/cap5.html#tipos-de-relaciones.",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.4 Tipos de relaciones.",
    "text": "5.4 Tipos de relaciones.\nPara una mejor explicación del tipo de relaciones hagamos un ejemplo teniendo presente el siguiente diagrama.\n\nEn el grafico anterior podemos observar que consta de lo siguiente: nombre | atributos | métodos.\nCon esta información realicemos ejemplos para un mejor entendimiento.\nSi tenemos una clase denominada Animales, cuyos atributos son nombre, ID, edad y sus métodos son definirNombre y comer.\nPara esto tener presente la información de la imagen siguiente.\n\nEs decir para representar atributos privados sería de la siguiente manera:\n-nombre | Atributo privado\n+ID | Atributo público\n#edad | Atributo protegido.\nTeniendo la representación de la clase como se observa en la siguiente imagen.\n\nQue sucedería si se quisiera crear 2 animales diferentes un perro y un gato.\n\nTendríamos el siguiente diagrama, sin embargo, aplicando el principio de herencia, podemos re utilizar el código, como se observa en la imagen siguiente.\n\nLa clase animales en la imagen anterior toma el nombre de clase padre o superclase y las clases de perro y gato toman el nombre de subclase o clase hija."
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#tipos-de-relaciones-en-diagramas-de-clases-uml",
    "href": "Unidades/unidad5/cap5.html#tipos-de-relaciones-en-diagramas-de-clases-uml",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.5 Tipos de relaciones en diagramas de clases UML:",
    "text": "5.5 Tipos de relaciones en diagramas de clases UML:\n\n\n\n\n\n\n5.5.1 Relación (Línea continua con flecha)\n\nEjemplo: Persona tiene una relación con Empleo.\nDescripción: Esta relación indica que una clase (Persona) está asociada a otra clase (Empleo). En este caso, una persona puede tener un empleo, lo que representa una asociación básica entre estas dos entidades.\nSímbolo: Línea continua con flecha.\n\n\n\n5.5.2 Implementación (Línea continua con triángulo)\n\nEjemplo: PagoConTarjeta implementa la InterfazPago.\nDescripción: En este caso, PagoConTarjeta debe proporcionar una implementación del método procesarPago() definido en la interfaz InterfazPago. Esto significa que PagoConTarjeta se compromete a cumplir con el contrato especificado por la interfaz.\nSímbolo: Línea continua con triángulo en la dirección de la interfaz.\n\n\n\n5.5.3 Composición (Línea continua con diamante lleno)\n\nEjemplo: Edificio contiene Aulas.\nDescripción: La composición representa una relación fuerte de “parte de”. En este caso, las aulas forman parte del edificio, y si el edificio se destruye, las aulas también desaparecen. Aula no puede existir sin Edificio.\nSímbolo: Línea continua con diamante lleno en el lado del todo (Edificio).\n\n\n\n5.5.4 Asociación (Línea continua)\n\nEjemplo: Profesor y Estudiante están asociados.\nDescripción: Indica una relación entre dos clases en la que ambas pueden interactuar entre sí. En este caso, un Profesor enseña a un Estudiante. Es una relación básica, sin dependencia fuerte ni implicaciones de pertenencia.\nSímbolo: Línea continua sin ningún otro símbolo.\n\n\n\n5.5.5 Herencia (Línea discontinua con triángulo)\n\nEjemplo: Carro hereda de Vehiculo.\nDescripción: La herencia indica una relación “es un tipo de”. Carro hereda de Vehiculo, lo que significa que Carro es una especialización de Vehiculo y hereda sus atributos y métodos. Este es un caso de polimorfismo donde Carro puede ser tratado como Vehiculo.\nSímbolo: Línea discontinua con triángulo apuntando hacia la superclase (Vehiculo).\n\n\n\n5.5.6 Dependencia (Línea discontinua con flecha)\n\nEjemplo: Usuario depende de AutenticacionService.\nDescripción: La dependencia indica que una clase (Usuario) utiliza otra clase (AutenticacionService) temporalmente para realizar una acción. En este ejemplo, Usuario depende de AutenticacionService para iniciar sesión. La relación es débil, lo que significa que Usuario solo necesita AutenticacionService temporalmente.\nSímbolo: Línea discontinua con flecha apuntando hacia la clase de la que depende (AutenticacionService).\n\n\n\n5.5.7 Agregación (Línea continua con diamante vacío)\n\nEjemplo: Perrera agrega Perro.\nDescripción: La agregación representa una relación de “parte de” débil. Perro es una parte de Perrera, pero puede existir independientemente de ella. Es decir, si la Perrera deja de existir, los Perros pueden seguir existiendo.\nSímbolo: Línea continua con un diamante vacío en el lado del todo (Perrera)."
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#asociación",
    "href": "Unidades/unidad5/cap5.html#asociación",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.6 Asociación:",
    "text": "5.6 Asociación:\nUtilizando una linea simple la asociación indica una relación entre dos clases sin dependencia.\nEjemplo si ahora creamos un animal (PEZ), podemos decir que los gatos pueden comer peces utilizando el diagrama que se observa en la siguiente imagen."
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#agregación",
    "href": "Unidades/unidad5/cap5.html#agregación",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.7 Agregación:",
    "text": "5.7 Agregación:\nEs un tipo especial de asociación que especifíca un todo y sus partes, esta relación indica que los elementos pueden existir fuera del todo. Ejemplo:\nSi creamos una clase Perro, y una clase Perrera, el perro podría pertenecer a la clase Perrera, pero no depende necesariamente la clase perro de la perrera y se representa como se observa en la siguiente imagen."
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#composición",
    "href": "Unidades/unidad5/cap5.html#composición",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.8 Composición:",
    "text": "5.8 Composición:\nEs la relación en la que la parte no puede existir fuera del todo sin la otra clase. Ejemplo, si tenemos un centro de visitantes en la cual tenga varios espacios físicos como recepción y baños, Si el centro de visitantes se derrumbara sus espacios físicos como recepción y baño no podrían exisitir separados."
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#multiplicidad.",
    "href": "Unidades/unidad5/cap5.html#multiplicidad.",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.9 Multiplicidad.",
    "text": "5.9 Multiplicidad.\nPermite restringir las restricciones numéricas de dependencia.\nEjemplo si queremos especificar que el centro de visitantes tiene un solo centro de recepción, y que puede tener uno o varios baños, se puede realizar la siguiente manera.\n\nSi tienes más dudas, te sugiero revisar el siguiente video:"
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#plantiumuml-herramienta",
    "href": "Unidades/unidad5/cap5.html#plantiumuml-herramienta",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.10 PlantiumUML herramienta",
    "text": "5.10 PlantiumUML herramienta\n@startuml\nclass Persona {\n    + nombre : String\n    + correr() : void\n}\n@enduml\n@startuml\nclass Persona {\n    + nombre : String\n    + correr() : void\n}\n\nclass Estudiante extends Persona {\n    + matricula : String\n    + estudiar() : void\n}\n@enduml"
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#plantiumuml-video",
    "href": "Unidades/unidad5/cap5.html#plantiumuml-video",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.11 PlantiumUML Video",
    "text": "5.11 PlantiumUML Video"
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#video",
    "href": "Unidades/unidad5/cap5.html#video",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.12 Video",
    "text": "5.12 Video"
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#test",
    "href": "Unidades/unidad5/cap5.html#test",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.13 TEST",
    "text": "5.13 TEST"
  },
  {
    "objectID": "Unidades/unidad6/cap6.html#funciones-y-métodos-los-nombres-de-funciones-y-métodos-deben-describir-lo-que-hacen.-es-una-buena-práctica-que-los-nombres-sean-verbos-o-frases-verbales.",
    "href": "Unidades/unidad6/cap6.html#funciones-y-métodos-los-nombres-de-funciones-y-métodos-deben-describir-lo-que-hacen.-es-una-buena-práctica-que-los-nombres-sean-verbos-o-frases-verbales.",
    "title": "6  Nombres Claros y Descriptivos",
    "section": "6.1 Funciones y Métodos Los nombres de funciones y métodos deben describir lo que hacen. Es una buena práctica que los nombres sean verbos o frases verbales.",
    "text": "6.1 Funciones y Métodos Los nombres de funciones y métodos deben describir lo que hacen. Es una buena práctica que los nombres sean verbos o frases verbales.\n\nEjemplo de un mal nombre:\n\n void d();  // ¿Qué significa \"d\"?\n\nEjemplo de un buen nombre:\n\n void dibujarRectangulo();"
  },
  {
    "objectID": "Unidades/unidad6/cap6.html#funciones-simples-y-de-responsabilidad-única",
    "href": "Unidades/unidad6/cap6.html#funciones-simples-y-de-responsabilidad-única",
    "title": "6  Nombres Claros y Descriptivos",
    "section": "6.2 Funciones Simples y de Responsabilidad Única",
    "text": "6.2 Funciones Simples y de Responsabilidad Única\nLas funciones deben ser cortas y realizar solo una tarea específica. Una función que intenta hacer muchas cosas es difícil de entender y mantener.\n\nEjemplo En lugar de hacer todo en una sola función, divide las tareas en funciones separadas.\nEjemplo de función compleja:\n\nvoid procesarDatosYGuardarEnBD() { // Procesa datos // Guarda en la base de datos \n}\nEjemplo de funciones separadas:\nvoid procesarDatos() {     // Procesa datos \n     }\nvoid guardarEnBD() {     // Guarda en la base de datos \n     }"
  },
  {
    "objectID": "Unidades/unidad6/cap6.html#evitar-comentarios-innecesarios",
    "href": "Unidades/unidad6/cap6.html#evitar-comentarios-innecesarios",
    "title": "6  Nombres Claros y Descriptivos",
    "section": "6.3 Evitar Comentarios Innecesarios",
    "text": "6.3 Evitar Comentarios Innecesarios\nUn código limpio debería ser lo suficientemente claro para no necesitar comentarios. Si sientes que necesitas comentar para explicar el código, es probable que el código en sí necesite ser refactorizado.\n\nEjemplo\n\nCódigo con comentarios innecesarios:\nint edad = 25; // Declara la edad del usuario \nCódigo claro sin comentarios:\nint edadUsuario = 25;"
  },
  {
    "objectID": "Unidades/unidad6/cap6.html#evitar-código-duplicado",
    "href": "Unidades/unidad6/cap6.html#evitar-código-duplicado",
    "title": "6  Nombres Claros y Descriptivos",
    "section": "6.4 Evitar Código Duplicado",
    "text": "6.4 Evitar Código Duplicado\nEl código duplicado genera inconsistencias y es difícil de mantener. Si necesitas hacer algo similar en múltiples lugares, utiliza funciones o métodos para reducir la duplicación.\nEjemplo de código duplicado:\n\nint calcularAreaRectangulo (int ancho, int alto) {\n          return ancho * alto; \n          }  \n\nint calcularAreaCuadrado(int lado) {\n          return lado * lado; \n          } \n          \nEjemplo de código refactorizado:\n\nint calcularArea(int ancho, int alto) {\n      return ancho * alto; \n      }"
  },
  {
    "objectID": "Unidades/unidad6/cap6.html#control-de-excepciones-y-errores",
    "href": "Unidades/unidad6/cap6.html#control-de-excepciones-y-errores",
    "title": "6  Nombres Claros y Descriptivos",
    "section": "6.5 Control de Excepciones y Errores",
    "text": "6.5 Control de Excepciones y Errores\nEl manejo de excepciones debe ser claro y específico. No uses excepciones generales como catch (Exception e) y evita el abuso de excepciones para el control de flujo.\n\nEjemplo\n\nMal manejo de excepciones:\n\ntry {\n// Código \n    } catch (Exception e) {\n        System.out.println(\"Ocurrió un error\"); \n    }\n    \nBuen manejo de excepciones:\n\ntry {     \n    \n      // Código \n    \n    } catch (IOException e) {  \n      \n      System.out.println(\"Error de entrada/salida\"); \n      \n      } catch (NullPointerException e) {\n      \n      System.out.println(\"Error: valor nulo encontrado\");\n      \n      }"
  },
  {
    "objectID": "Unidades/unidad6/cap6.html#uso-de-formato-consistente",
    "href": "Unidades/unidad6/cap6.html#uso-de-formato-consistente",
    "title": "6  Nombres Claros y Descriptivos",
    "section": "6.6 Uso de Formato Consistente",
    "text": "6.6 Uso de Formato Consistente\nEl código debe tener un formato consistente para mejorar su legibilidad. Esto incluye el uso adecuado de sangría, espacios y estilo de llaves. Además, el equipo de desarrollo debe seguir una convención de formato común.\n\n6.6.1 Ejemplo\nMal formato:\n\nif(condicion){ \n    doSomething(); \n    } \nBuen formato:\nif (condicion) {\n  doSomething(); \n  }"
  },
  {
    "objectID": "Unidades/unidad6/cap6.html#reducir-el-número-de-parámetros",
    "href": "Unidades/unidad6/cap6.html#reducir-el-número-de-parámetros",
    "title": "6  Nombres Claros y Descriptivos",
    "section": "6.7 Reducir el Número de Parámetros",
    "text": "6.7 Reducir el Número de Parámetros\nLas funciones con muchos parámetros son difíciles de entender y usar correctamente. Intenta reducir el número de parámetros pasando objetos cuando sea posible.\nEjemplo de demasiados parámetros:\nvoid crearUsuario(String nombre, String apellido, int edad, String direccion) {\n// Crear usuario \n} \nEjemplo de uso de un objeto:\n// Main.java\n\n// Definición de la clase Usuario\nclass Usuario {\n    String nombre;\n    String apellido;\n    int edad;\n    String direccion;\n\n    // Constructor para inicializar los atributos de Usuario\n    public Usuario(String nombre, String apellido, int edad, String direccion) {\n        this.nombre = nombre;\n        this.apellido = apellido;\n        this.edad = edad;\n        this.direccion = direccion;\n    }\n\n    // Método para mostrar la información del usuario\n    public void mostrarInformacion() {\n        System.out.println(\"Nombre: \" + nombre);\n        System.out.println(\"Apellido: \" + apellido);\n        System.out.println(\"Edad: \" + edad);\n        System.out.println(\"Dirección: \" + direccion);\n    }\n}\n\n// Clase principal con el método crearUsuario\npublic class Main {\n\n    // Método para \"crear\" un usuario (en este caso, solo muestra la información)\n    public static void crearUsuario(Usuario usuario) {\n        System.out.println(\"Creando usuario...\");\n        usuario.mostrarInformacion();\n    }\n\n    public static void main(String[] args) {\n        // Crear una instancia de Usuario\n        Usuario usuario = new Usuario(\"Luis\", \"Jaramillo\", 30, \"Calle Falsa 123\");\n\n        // Llamar al método crearUsuario\n        crearUsuario(usuario);\n    }\n}"
  },
  {
    "objectID": "Unidades/unidad6/cap6.html#pruebas-unitarias",
    "href": "Unidades/unidad6/cap6.html#pruebas-unitarias",
    "title": "6  Nombres Claros y Descriptivos",
    "section": "6.8 Pruebas Unitarias",
    "text": "6.8 Pruebas Unitarias\nEs importante escribir pruebas unitarias para el código. Las pruebas ayudan a detectar errores y aseguran que el código funcione correctamente a medida que evoluciona.\n\nEjemplo de prueba unitaria en Java\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculadoraTest {\n\n    @Test\n    public void testSuma() {\n        Calculadora calc = new Calculadora();\n        assertEquals(5, calc.suma(2, 3));\n    }\n}\n## [TEST](https://forms.gle/pRTgrvN2GhVDRkqw7)"
  },
  {
    "objectID": "Unidades/unidad7/cap7.html#estructura-general-de-un-programa-en-java.",
    "href": "Unidades/unidad7/cap7.html#estructura-general-de-un-programa-en-java.",
    "title": "7  Estructura General de un Programa en JAVA",
    "section": "7.1 ESTRUCTURA GENERAL DE UN PROGRAMA EN JAVA.",
    "text": "7.1 ESTRUCTURA GENERAL DE UN PROGRAMA EN JAVA.\nLa estructura general de un programa orientado a objetos depende del lenguaje de programación que se utilice, pero en general se basa en los siguientes elementos:\n\nClases: Son las plantillas o modelos que definen las propiedades y los métodos comunes de un conjunto de objetos. Las clases se pueden organizar en jerarquías mediante la herencia, que permite reutilizar y extender el código de las clases superiores a las clases inferiores.\nObjetos: Son las instancias o ejemplares de las clases, que tienen un estado (valores de los atributos) y un comportamiento (ejecución de los métodos) específicos. Los objetos se pueden comunicar entre sí mediante mensajes, que son las llamadas a los métodos de otros objetos.\nRelaciones: Son los vínculos o conexiones que existen entre las clases y los objetos, que indican cómo se relacionan o interactúan entre sí. Hay diferentes tipos de relaciones, como la asociación, la dependencia, la generalización, la realización, la agregación y la composición.\n\nVeamos paso a paso un ejemplo de un programa orientado a objetos.\nAntes de empezar, utilizaremos la imagen que utilizamos en modelamiento y se encuentra a continuación.\n\nPara el ejemplo utilizaremos el nombre de clase “Person”, están indicados los métodos y atributos en privado para mejor entendimiento cambiaremos de privado a default, por lo que el código quería así.\npublic class Person{\n  String name;  // Atributo 1\n  int birthDate; // Atributo 2\n  \n  public Person(String name, int birthDate) {  //constructor\n        this.name = name;\n        this.birthDate = birthDate;\n    }\n  \n  public void isBirthday(){    //método\n    System.out.println(\"imprimir la fecha\");\n  }\n}\nUn ejemplo más completo es el siguiente:\n// Clase Persona\npublic class Persona {\n  // Atributos\n  String nombre;\n  int edad;\n  String dni;\n\n  // Constructor\n  public Persona(String nombre, int edad, String dni) {\n    this.nombre = nombre;\n    this.edad = edad;\n    this.dni = dni;\n  }\n\n  public void saludar() {\n    System.out.println(\"Hola, me llamo \" + nombre + \" y tengo \" + edad + \" años.\");\n  }\n}\n\n// Clase Estudiante que hereda de Persona\npublic class Estudiante extends Persona {\n  // Atributos\n  public String carrera;\n  public double notaMedia;\n\n  // Constructor\n  public Estudiante(String nombre, int edad, String dni, String carrera, double notaMedia) {\n    // Llamada al constructor de la superclase\n    super(nombre, edad, dni);\n    this.carrera = carrera;\n    this.notaMedia = notaMedia;\n  }\n\n  public void estudiar() {\n    System.out.println(\"Estoy estudiando \" + carrera + \".\");\n  }\n\n  public void examinar() {\n    System.out.println(\"Me voy a examinar de \" + carrera + \".\");\n  }\n\n  // Sobrescritura del método saludar de la superclase\n  @Override\n  public void saludar() {\n    System.out.println(\"Hola, soy \" + nombre + \", estudiante de \" + carrera + \" y tengo una nota media de \" + notaMedia + \".\");\n  }\n}\n\n// Clase Profesor que hereda de Persona\npublic class Profesor extends Persona {\n  // Atributos\n  String asignatura;\n  double salario;\n\n  // Constructor\n  public Profesor(String nombre, int edad, String dni, String asignatura, double salario) {\n    // Llamada al constructor de la superclase\n    super(nombre, edad, dni);\n    this.asignatura = asignatura;\n    this.salario = salario;\n  }\n\n  public void enseñar() {\n    System.out.println(\"Estoy enseñando \" + asignatura + \".\");\n  }\n\n  public void evaluar() {\n    System.out.println(\"Voy a evaluar a mis alumnos de \" + asignatura + \".\");\n  }\n\n  // Sobrescritura del método saludar de la superclase\n  @Override\n  public void saludar() {\n    System.out.println(\"Hola, soy \" + nombre + \", profesor de \" + asignatura + \" y cobro \" + salario + \" euros al mes.\");\n  }\n}\n\n// Clase principal con el método main\npublic class Main {\n  public static void main(String[] args) {\n    // Creación de objetos\n    Persona p1 = new Persona(\"Ana\", 25, \"12345678A\");\n    Estudiante e1 = new Estudiante(\"Luis\", 20, \"87654321B\", \"Informática\", 8.5);\n    Profesor pr1 = new Profesor(\"Pedro\", 35, \"45678912C\", \"Matemáticas\", 1500);\n\n    // Llamada a los métodos de los objetos\n    p1.saludar();\n    e1.saludar();\n    pr1.saludar();\n    e1.estudiar();\n    pr1.enseñar();\n  }\n}\nTodo el código pertenece al siguiente esquema.\n\n\n\n\n\nEste programa define tres clases: Persona, Estudiante y Profesor. La clase Estudiante y la clase Profesor heredan de la clase Persona, lo que significa que comparten sus atributos y métodos, y añaden algunos propios. El programa crea tres objetos: uno de cada clase, y llama a sus métodos. El resultado es el siguiente:\nHola, me llamo Ana y tengo 25 años.\nHola, soy Luis, estudiante de Informática y tengo una nota media de 8.5.\nHola, soy Pedro, profesor de Matemáticas y cobro 1500 euros al mes.\nEstoy estudiando Informática.\nEstoy enseñando Matemáticas."
  },
  {
    "objectID": "Unidades/unidad7/cap7.html#video",
    "href": "Unidades/unidad7/cap7.html#video",
    "title": "7  Estructura General de un Programa en JAVA",
    "section": "7.2 Video",
    "text": "7.2 Video"
  },
  {
    "objectID": "Unidades/unidad8/cap8.html#introducción-a-la-entrada-y-salida-en-consola",
    "href": "Unidades/unidad8/cap8.html#introducción-a-la-entrada-y-salida-en-consola",
    "title": "8  Lectura y Escritura de Datos por Consola",
    "section": "8.1 Introducción a la Entrada y Salida en Consola",
    "text": "8.1 Introducción a la Entrada y Salida en Consola\nLa interacción por consola en Java permite a los desarrolladores capturar información ingresada por el usuario y devolver resultados o mensajes. En Java, la entrada y salida (E/S) de datos es fundamental para muchos programas, y este capítulo se centra en métodos prácticos para implementar E/S en aplicaciones de consola. A través de ejemplos prácticos, entenderás cómo utilizar las clases y métodos esenciales para obtener y mostrar información en el entorno de línea de comandos."
  },
  {
    "objectID": "Unidades/unidad8/cap8.html#entrada-de-datos",
    "href": "Unidades/unidad8/cap8.html#entrada-de-datos",
    "title": "8  Lectura y Escritura de Datos por Consola",
    "section": "8.2 Entrada de datos",
    "text": "8.2 Entrada de datos\n\n8.2.1 Clase Scanner\nLa clase Scanner es la herramienta más común para la entrada de datos en Java. Pertenece al paquete java.util y permite leer diferentes tipos de datos: cadenas, enteros, decimales y booleanos. El uso de Scanner facilita la captura de datos con el método next() para cadenas o nextInt(), nextDouble(), entre otros, para tipos específicos.\n\nEjemplo: Leer un número y un nombre\n\nimport java.util.Scanner;\n\npublic class EjemploScanner {\n    public static void main(String[] args) {\n        Scanner entrada = new Scanner(System.in);\n\n        System.out.print(\"Ingresa tu nombre: \");\n        String nombre = entrada.nextLine();\n\n        System.out.print(\"Ingresa tu edad: \");\n        int edad = entrada.nextInt();\n\n        System.out.println(\"Hola \" + nombre + \", tienes \" + edad + \" años.\");\n    }\n}\n\nnextLine(): captura una línea completa de texto, incluyendo espacios.\nnextInt(): captura un número entero.\n\nPrecaución al Leer Datos en Java\nEs importante tener cuidado al alternar la lectura de datos de diferentes tipos en Java, especialmente cuando se combinan enteros o decimales (int, float, etc.) con cadenas (String). Después de leer un valor numérico con métodos como nextInt() o nextFloat(), el buffer de entrada puede contener un salto de línea (\\n) residual. Esto puede causar que una llamada posterior a nextLine() lea dicho salto de línea en lugar de capturar la cadena esperada. Para evitar errores, se recomienda limpiar el buffer antes de leer una cadena, usando nextLine() adicionalmente.\n\n\nimport java.util.Scanner;\n\npublic class principal {\n    public static void main(String[] args) {\n        Scanner lectura = new Scanner(System.in); // 'in' significa entrada, 'out' significa salida\n        // Ejemplo de lectura de datos\n        System.out.print(\"Ingrese su nombre: \");\n        String nombre = lectura.nextLine(); // Leemos un dato tipo cadena de caracteres\n        System.out.print(\"Ingrese su edad: \");\n        int edad = lectura.nextInt(); // Leemos un dato tipo entero\n        System.out.print(\"Salario: \");\n        float salario = lectura.nextFloat();\n        // Limpiar el buffer después de leer un entero\n        lectura.nextLine();\n        System.out.print(\"Ingrese su apellido: \");\n        String apellido = lectura.nextLine();\n\n        // ¿Qué pasará si no limpiamos el buffer?\n        System.out.println(\"¿Qué pasará si no limpiamos el buffer?\");\n\n        System.out.print(\"Ingrese su nombre2: \");\n        String nombre2 = lectura.nextLine();\n        System.out.print(\"Ingrese su edad2: \");\n        int edad2 = lectura.nextInt();\n        System.out.print(\"Salario2: \");\n        float salario2 = lectura.nextFloat();\n        System.out.print(\"Ingrese su apellido: \");\n        String apellido2 = lectura.nextLine();\n        // Cerrar el scanner al finalizar\n        lectura.close();\n\n        // Ejemplo de escritura de datos\n        System.out.println(\"******************************\");\n        System.out.println(\"\\nInformación ingresada1:\");\n        System.out.println(\"Nombre: \" + nombre);\n        System.out.println(\"Apellido: \" + apellido);\n        System.out.println(\"Edad: \" + edad);\n        System.out.println(\"Salario: \" + salario);\n\n\n        System.out.println(\"******************************\");\n        System.out.println(\"\\nInformación ingresada2:\");\n        System.out.println(\"Nombre2: \" + nombre2);\n        System.out.println(\"Apellido: \" + apellido2);\n        System.out.println(\"Edad2: \" + edad2);\n        System.out.println(\"Salario2: \" + salario2);\n    }\n    \n}\n\nLimpieza de Buffer: Luego de leer int o float, se utiliza lectura.nextLine(); para limpiar el buffer antes de leer un String con nextLine().\nEvitar Errores: Al no limpiar el buffer, el programa puede no capturar la entrada del usuario como se espera y leer datos incorrectos o vacíos.\n\n\n\n8.2.2 Uso de BufferedReader\nBufferedReader es otra opción para la lectura de datos y es especialmente útil para aplicaciones que requieren un manejo eficiente de grandes volúmenes de datos. Utiliza InputStreamReader para leer desde System.in.\nEjemplo: Leer una cadena de texto\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class EjemploBufferedReader {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        System.out.print(\"Ingresa un mensaje: \");\n        String mensaje = reader.readLine();\n\n        System.out.println(\"Mensaje recibido: \" + mensaje);\n    }\n}\nExplicación:\n\nreadLine(): lee una línea de texto completa, ideal para capturar grandes bloques de datos."
  },
  {
    "objectID": "Unidades/unidad8/cap8.html#escritura-de-datos-en-la-consola",
    "href": "Unidades/unidad8/cap8.html#escritura-de-datos-en-la-consola",
    "title": "8  Lectura y Escritura de Datos por Consola",
    "section": "8.3 Escritura de Datos en la Consola",
    "text": "8.3 Escritura de Datos en la Consola\n\n8.3.1 Uso de System.out.println\nSystem.out.println es el método más sencillo y común para mostrar datos en la consola. Acepta texto y datos variables, permitiendo mostrar mensajes, resultados, y más.\nEjemplo: Saludo Básico\npublic class EjemploPrintln {\n    public static void main(String[] args) {\n        System.out.println(\"Bienvenido al sistema.\");\n        System.out.println(\"Este mensaje aparecerá en una nueva línea.\");\n    }\n}\nFormateo de Salida con System.out.printf\nEl método printf permite controlar el formato de la salida, especialmente útil cuando se requiere una presentación organizada de datos, como tablas o valores numéricos con un número específico de decimales.\nEjemplo: Formateo con printf\npublic class EjemploPrintf {\n    public static void main(String[] args) {\n        String producto = \"Laptop\";\n        double precio = 1234.56;\n\n        System.out.printf(\"Producto: %s, Precio: %.2f\\n\", producto, precio);\n    }\n}\n\n%s es un marcador de posición para cadenas.\n%.2f indica un número decimal con dos dígitos después del punto.\n\nEjemplo 2 : Formateo con printf\npublic class Ejemplo2Printf {\n    public static void main(String[] args) {\n        String nombre = \"Ana\";\n        int edad = 25;\n\n        System.out.printf(\"Nombre: %s, Edad: %d años\\n\", nombre, edad);\n    }\n}\nSalida esperada: Nombre: Ana, Edad: 25 años"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "10  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "Unidades/unidad9/cap9.html#introducción",
    "href": "Unidades/unidad9/cap9.html#introducción",
    "title": "9  Manejo de excepciones.",
    "section": "9.1 Introducción",
    "text": "9.1 Introducción\nEl manejo de excepciones en Java es una característica fundamental que permite gestionar errores durante la ejecución de un programa, evitando que se interrumpa abruptamente. Las excepciones representan condiciones inusuales o errores que pueden ocurrir, como intentos fallidos de abrir un archivo o la entrada de datos inválidos."
  },
  {
    "objectID": "Unidades/unidad9/cap9.html#conceptos-básicos",
    "href": "Unidades/unidad9/cap9.html#conceptos-básicos",
    "title": "9  Manejo de excepciones.",
    "section": "9.2 Conceptos Básicos",
    "text": "9.2 Conceptos Básicos\n\n9.2.1 ¿Qué es una excepción?\nUna excepción es un evento que ocurre durante la ejecución de un programa y que interrumpe el flujo normal de las instrucciones. En Java, todas las excepciones son objetos que heredan de la clase base Throwable.\n\n\n9.2.2 Jerarquía de Excepciones\n\nThrowable: Clase base de todas las excepciones y errores.\n\nException: Errores que pueden ser manejados por el programa.\n\nIOException: Relacionadas con operaciones de entrada/salida.\nSQLException: Errores en bases de datos.\nFileNotFoundException: Archivo no encontrado.\nArithmeticException: Errores matemáticos como división por cero.\n\nError: Condiciones críticas del sistema, como falta de memoria, que no deben manejarse directamente.\n\nUso de throw\nEjemplo lanzando una excepción\n\n\nimport java.io.FileReader;\npublic class Throws {\n\n     public static void main(String[] args) {\n        \n        FileReader archivo = new FileReader(\"archivo_inexistente.txt\"); // Puede lanzar FileNotFoundException\n        System.out.println(\"Archivo abierto con éxito.\");\n      \n    }\n    \n}\nsaldrá el siguiente mensaje: Exception in thread “main” java.lang.RuntimeException: Uncompilable code - unreported exception java.io.FileNotFoundException; must be caught or declared to be thrown at exepciones.Exepciones.main(\nEspañol: Excepción en el hilo “main” java.lang.RuntimeException: Código no compilable - excepción no reportada java.io.FileNotFoundException; debe ser capturada o declarada para lanzarse en exepciones.Exepciones.main(\nEjemplo: Si ahora sólo lanzaramos la excepción con la palabra throws obtendríamos el siguiente mensaje.\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\n\npublic class Exepciones {\n\n    public static void main(String[] args) throws FileNotFoundException {\n        \n        FileReader archivo = new FileReader(\"archivo_inexistente.txt\"); // Puede lanzar FileNotFoundException\n        System.out.println(\"Archivo abierto con éxito.\");\n    }\n    \n}\nException in thread “main” java.io.FileNotFoundException: archivo_inexistente.txt (El sistema no puede encontrar el archivo especificado).\nUso de try y catch\nEjemplo básico:\npublic class EjemploTryCatch {\n    public static void main(String[] args) {\n        try {\n            int resultado = 10 / 0; // Genera ArithmeticException\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error: No se puede dividir entre cero.\");\n        }\n    }\n}"
  }
]